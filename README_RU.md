# accp
Access Control Caching Proxy

## Причины создания  

Nginx прекрасный инструмент для повышения производительности бэкенда, но есть несколько моментов, где он не удовлетворяет на все 100%.
### Кэширование  

Основная проблема всех кэширующих http прокси это инвалидация кэша. Nginx инвалидирует кэш по TTL, с использованием HTTP PURGE-метода, или путём ручного удаления кэша. Но в ряде случаев этого недостаточно. Не нужно удалять кэш, достаточно его обновить по определённым событиям. Например, периодическое обновление кэша или после определённого количества запросов. Nginx позволяет выполнить обновление просроченного элемента кэша, но возможности обновить кэш до момента, когда он будет просрочен, кроме как удалить его, нет. Возможно реализовать периодическое обновления с использованием PURGE-метода, периодически отправляя запрос с ним к API, но это потребует разработки или отдельного расширения или отдельного сервиса.  
Стандартный Nginx хранит кэш в файловой системе, что больше ориентировано на кэширование страниц, а не REST. Есть поддержка кэширования через общий Redis. Хранение в inmemory доступно только для Nginx Plus.

### Расширения на разных языках  

Nginx поддерживает расширения на различных языках.  
Например, он позволяет выполнить интроспекцию OAuth2-токенов и обогатить их содержимым запрос с помощью скриптов на JavaScript. Он может даже закэшировать результаты интроспекции, но это создаёт риски при отзыве токенов. Ещё важный момент, что интроспекция не выполняется при попытке фонового обновления просроченного элемента кэша.  
При использовании кэша зачастую не выполняется бизнес-логика, которая требуется для сбора аналитической информации. Запросов на бэк нет. В nginx можно с помощью скриптов (lua) добавить отправку тела запроса в RabbitMQ, откуда бэк сможет забрать их для выполнения бизнес-логики, которая требуется для сбора аналитической информации.  
В результате получается или «зоопарк» скриптов на разных языках или необходимость переписывать готовые и отработанные модули на один язык. И в том и в другом случае требуется дальнейшая поддержка и сопровождение.

### Мониторинг  

Для Nginx есть экспортёр метрик в Prometheus, написанный на go. Но он не охватывает расширения, и его придётся дорабатывать, а сами расширения дополнять необходимыми метриками.  
Стандартный Nginx поддерживает ограниченное количество метрик, для расширенного мониторинга нужен Nginx Plus.

## Возможности ACCP
* интроспекция OAuth2-токенов и обогащением телом токенов запросов;
* ограничение количества запросов на бэкенд;
* двухуровневое кэширование ответов бэкенда;
* пересылка не кэшируемых запросов на бэк;
* автоматическое обновление кэша по времени, либо после заданного количества запросов;
* отправка событий в очередь для бизнес-аналитики;
* конфигурирование через yml файл.

### Интроспекция OAuth2-токенов и обогащения запросов
ACCP может выполнить экстракцию и отправку OAuth2-токена на интроспекцию. Если интроспекцию прошла неуспешно, будет возвращён код 401.
Интроспекция выполняется на каждый запрос, даже если ответ уже есть в кэше.
При необходимости можно обогатить запрос телом токена. Тело токена будет добавлено как отдельный заголовок, парсинг по полям и добавление отдельных полей токена в запрос не выполняется.
Для совместимости с различными системами авторизации, запрос в OAuth2-сервис формируется на основании шаблона.
Т.к. при кэшировании учитывается заголовок с телом токена, то предусматривается тримминг не нужных полей, задаются в конфигурации.
При выполнении запросов на обновлении кэша, интроспекция также выполняется, поэтому если токен для кэшированного запроса устарел, данные обновлены не будут.  
Необходимость интроспекции и необходимость обогащения запроса телом токена задаётся на уровне маршрутов.

### Ограничение количества запросов на бэкенд
Множество клиентов выполняют асинхронные запросы в ACCP, но он организует их в последовательность.
ACCP отправляет на бэкенд только первый запрос и все остальные запросы ждут ответа на первый запрос.
Это аналогично опцией proxy_cache_lock в nginx.

### Ограничение количества запросов в единицу времени (rate-limit)
Для снижения нагрузки как на ACCP так и на клиентов, реализован механизм ограничения обработки количества запросов на базе алгоритма fixed window. По определённому условию (access-токен, IP, специальный заголовок) при первом запросе фиксируется момент времени и каждый запрос инкрементирует счётчик. Как только будет достигнуто максимальное значение счётчика, будет возвращён код 429.
Когда заданный таймаут будет завершён, новые запросы снова будут выполнятся, пока не будет достигнут лимит.

### Пересылка не кэшируемых запросов на бэк
Не все запросы требуют кэширования, все не кэшируемый запросы пересылаются на бэкенд.

### Двухуровневый кэш
В ACCP реализован двухуровневый кэш. L1 кэш для кэширования ответов бэка в памяти сервиса. L2 кэш для кэширования ответов в Redis. L1 обеспечивает высокую производительность сервиса. L2 позволяет быстро прогреть и синхронизировать несколько экземпляров сервиса. При добавлении значения в кэш, происходит вычисление ключа на основании тела запроса, параметров запроса и заголовка с результатом интроспекции. Для каждого нового значения генерируется UUID. При запросе значения из кэша, выполняется проверка в Redis, было ли изменение значения. Проверка выполняется на основе сравнения UUID в L1 и L2. Для быстрого получения UUID без полного содержимого значения в кэше  используется RedisJSON. Каждое обращение к закэшированному значению продлевает его TTL.  
Кроме ответов в L1 кэшируются запросы для обновления в кэше ответов от бэка. В L2 запросы не сохраняются.  
Возможно разделение конфигурирование TTL для кэшированных ответов бэкенда с ошибкой и без. В случае если от бэкенда получена ошибка, ответ будет сохранён в кэше, но его TTL не будет продлеваться при обращении за ним.  
Обновление значений в кэше возможно периодически или по количеству запросов и не завязано на продление TTL. Продление TTL выполняется только при обращении клиентов к API. Если к значению нет обращений, то он будет удалён и его не будут обновлять.  Обновление кэша выполняется асинхронно.  
В ACCP возможно кэширование POST-запросов.

### Автоматическое обновление кэша
Обновление кэша выполняется автоматически через заданный период или, при наличии настройки, при достижении заданного количества запросов к API. При ошибке обновления, закэшированный ответ удаляется из кэша.

### Отправка событий в очередь для бизнес-аналитики
При каждом обращении к API через ACCP запрос дублируется и отправляется в очередь RabbitMQ для последующего разбора бэком для выполнения бизнес-логики для аналитики

### Конфигурирование через yml-файл
ACCP конфигурируется полностью через yml файл. Возможно индивидуальное задание настроек для отдельных маршрутов к API, поддерживается наследование для задания общих настроек для группы API с последующим уточнением каких-либо настроек для отдельных обработчиков. Можно исключать отдельные обработчики, чтобы их ответы не кэшировались.

## Архитектура
![accp-arhitecture](http://www.plantuml.com/plantuml/proxy?cache=no&src=https://raw.githubusercontent.com/soldatov-s/accp/alfa/doc/accp.puml?token=ALAUH2AQ2LEAFIN5EYN4SAK7WAND6)  

![accp-sequence](http://www.plantuml.com/plantuml/proxy?cache=no&src=https://raw.githubusercontent.com/soldatov-s/accp/alfa/doc/accp-sequence.puml?token=ALAUH2AQ2LEAFIN5EYN4SAK7WAND6)


  