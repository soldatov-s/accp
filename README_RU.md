# accp
Access Control Caching Proxy

## Причины создания  

Nginx прекрасный инструмент для повышения производительности бэкенда, но есть несколько моментов, где он не удовлетворяет на все 100%.
### Кэширование  

Основная проблема всех кэширующих http прокси это инвалидация кэша.
Nginx инвалидирует кэш по TTL, с использованием HTTP PURGE-метода, или путём ручного удаления кэша.
Но в ряде случаев этого недостаточно. Не нужно удалять кэш, достаточно его обновить по определённым событиям.
Например, периодическое обновление кэша или после определённого количества запросов.
Nginx позволяет выполнить обновление просроченного элемента кэша, но возможности обновить кэш до момента, когда он будет просрочен, кроме как удалить его, нет.
Также, стандартный Nginx хранит кэш в файловой системе или через общий Redis. Хранение в inmemory доступно только для Nginx Plus, что сказывается на производительности при кэшировании запросов. 
### Расширения на разных языках  

Nginx поддерживает расширения на различных языках.  
Например, он позволяет выполнить интроспекцию OAuth2-токенов и обогатить их содержимым запрос с помощью скриптов на JavaScript. Он может даже закэшировать результаты интроспекции, но это создаёт риски при отзыве токенов. Ещё важный момент, что интроспекция не выполняется при попытке фонового обновления просроченного элемента кэша.  
При использовании кэша зачастую не выполняется бизнес-логика, которая требуется для сбора аналитической информации. Запросов на бэк нет. В nginx можно с помощью скриптов (lua) добавить отправку тела запроса в RabbitMQ, откуда бэк сможет забрать их для выполнения бизнес-логики, которая требуется для сбора аналитической информации.  
В результате получается или «зоопарк» скриптов на разных языках или необходимость переписывать готовые и отработанные модули на один язык. И в том и в другом случае требуется дальнейшая поддержка и сопровождение.

### Мониторинг  

Для Nginx есть экспортёр метрик в Prometheus, написанный на go. Но он не охватывает расширения, и его придётся дорабатывать, а сами расширения дополнять необходимыми метриками.

## Возможности ACCP
* интроспекция OAuth2-токенов и обогащением телом токенов запросов;
* ограничение количества запросов на бэкенд;
* двухуровневое кэширование ответов бэкенда;
* пересылка не кэшируемых запросов на бэк;
* атоматическое обновление кэша по времени, либо после заданного количества запросов;
* отправка событий в очередь для бизнес-аналитики;
* кофигурирование через yml файл.

### Интроспекция OAuth2-токенов и обогащения запросов
ACCP может выполнить экстракцию и отправку OAuth2-токена на интроспекцию. Если интроспекцию прошла неуспешно, будет возвращён код 401.
Интроспекция выполняется на каждый запрос, даже если ответ уже есть в кэше.
При необходимости можно обогатить запрос телом токена. Тело токена будет добавлено как отдельный заголовок, парсинг по полям и добавление отдельных полей токена в запрос не выполняется.
Для совместимости с различными системами авторизации, запрос в OAuth2-сервис формируется на основании шаблона.
Т.к. при кэшировании учитываются все заголовки запроса, то предусматривается тримминг не нужных полей.
При выполнении запросов на обновлении кэша, интроспекция также выполняется, поэтому если токен для кэшированного запроса устарел, данные обновлены не будут.

### Ограничение количества запросов на бэкенд
Множество клиентов выполняют асинхронные запросы в ACCP, но он организует их в последовательность.
ACCP отправляет на бэкенд только первый запрос и все остальные запросы ждут ответа на первый запрос.
Это аналогично опцией proxy_cache_lock в nginx.

### Ограничение количества запросов в единицу времени (rate-limit)
Для снижения нагрузки как на ACCP так и на клиентов, реализован механизм ограничения обработки количества запросов на базе алгоритма fixed window. По определённому условию (access-токен, IP, специальный заголовок) при первом запросе фиксируется момент времени и каждый запрос инкрементирует счётчик. Как только будет достигнуто максимальное значение счётчика, будет возвращён код 429.
Когда заданный таймаут будет завершён, новые запросы снова будут выполнятся, пока не будет достигнут лимит.

### Пересылка не кэшируемых запросов на бэк
Не все запросы требуют кэширования, все не кэшируемый запросы пересылаются на бэкенд.

### Двухуровневый кэш
В ACCP реализован двухуровневый кэщ. L1 кэш для кэширования ответов бэка в памяти сервиса. L2 кэш для кэширования ответов в Redis.
L1 обеспечивает выкоскую производительность сервиса. L2 позволяет быстро прогреть и синхронизировать несколько эксземпляров сервиса.
При добавлении значения в кэш, происходит вычисление ключа на основании тела запроса, параметров запроса, и заголовка с результатом интроспекции. Для каждого нового значения генерируется UUID.
При запросе значения из кэша, выполняется проверка в Redis, было ли изменение значения. Проверка выполняется на основе сравнения UUID в L1 и L2.
В ACCP возможно кэширование POST-запросов.

### Автоматическое обновление кэша
Обновление кэша выполняется автоматически через заданный период или, при наличии настройки, при достижении заданного количества запросов к API. При ошибке обновления, закэшированный ответ удаляется из кэша.

### Отправка событий в очередь для бизнес-аналитики
При каждом обращении к API через ACCP запрос дублируется и отправляется в очередь RabbitMQ для последующего разбора бэком для выполнения бизнес-логики для аналитики

### Конфигурирование через yml-файл
ACCP конфигурируется полностью через yml файл.

## Архитектура
![accp-arhitecture](http://www.plantuml.com/plantuml/proxy?cache=no&src=https://raw.githubusercontent.com/soldatov-s/accp/alfa/doc/accp.puml?token=ALAUH2AQ2LEAFIN5EYN4SAK7WAND6)  

![accp-sequence](http://www.plantuml.com/plantuml/proxy?cache=no&src=https://raw.githubusercontent.com/soldatov-s/accp/alfa/doc/accp-sequence.puml?token=ALAUH2AQ2LEAFIN5EYN4SAK7WAND6)


  